{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf200
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 COSC 4393 - Digital Image Processing\
\
Assignment 3\
\
I started off by working on the implementing the dft file first. It was hard to figure out the complex numbers and its usage in python. I tried using the original matrix to store the new complex values but it did not work. I had to ask around and the people in class told me that I should have made a new matrix of type \'91complex\'92 so I did and it stopped giving me errors. However, I do not know how I can verify that my calculations were correct because I see a lot of numbers in the output and I got light headed. I implemented the calculations based on the formulas given in the pdf for the homework. Sine and Cosine took me a while to figure out how to use them. When I was working through complex numbers, I tried different libraries such as math and cmath. In the end, I used math because it seemed the simplest. Calculating the magnitude took me half an hour more than I would expect because I did not know that python has a simple way to extract the real and imaginary values. I had to look it up. In the end, I managed to output the magnitude, though I am not sure that it is correct.\
\
Filtering is another story. I started off with the ideal low pass filter. I looked through the pdf on the class website to find out what is the calculation to do it. I then got stuck at the part of figuring out what \'93shape\'94 in the argument is. Turns out, it is just like the np.shape() that I have been using for a while. Everything went by faster after that point since I only adhere to the given formulas in all the pdfs, including full contrast stretching. Then there is the problem of implementing the filtering function. I stuck to the guides as best as I could. There is the problem with the code in the functions that does not take the order argument. So I had to put in extra arguments in ideal low and pass, gaussian low and high pass filter functions to make it work. Everything is easier once I am allowed to use the built-in functions. \
\
When I tried to use the butterworth filter with an order of 7, there is a error that occurred. It says that the program tried to divide by 0. So I will make a check for that. if the d is 0 then the function will just use 0 as the mask[u, v] value. I printed out the values for when d = 0, P = 512, Q = 512, u = 256, v = 256. Indeed, it resulted in d = 0 when I calculated by hand. However, I find that this error can only occur when using the butterworth high pass filter and not the low pass one. \
\
Apparently, I am at the very low end of the class. I messed up and the output folder was gone when I tried to pull from Github. I added the output folder manually but I can\'92t be certain if it really worked.}